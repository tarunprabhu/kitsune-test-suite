#!/usr/bin/env sh
#
# There might be some way of passing options to lit via a config file, but I
# haven't found it if it exists. This script cannot be used on Windows, but we
# don't support Windows in Kitsune anyway.

usage="
Run the Kitsune tests. This passes the right options to lit.

  USAGE

      run-tests [-b <dir>][-h]

  OPTIONS

      -h          Show help and exit

      -o <file>   Where to write the combined report. If this is not given, it
                  will be written to report.json in the Kistune/ subdirectory of
                  the test suite

      -b <dir>    The Kitsune build directory. This is useful if we strictly
                  need the llvm-lit executable that is present there. Otherwise,
                  the lit executable from $PATH will be used
"

# This will be the Kitsune/ subdirectory within the root of the llvm-test-suite
# build directory
kitsune=$(dirname $0)
test_suite=$(dirname "${kitsune}")

build_dir=""
outfile="${kitsune}/report.json"

while getopts "b:ho:" opt; do
    case "${opt}" in
        b)
            build_dir="${OPTARG}"
            ;;
        h)
            echo "${usage}"
            exit 0
            ;;
        o)
            outfile="${OPTARG}"
            ;;
    esac
done

lit=
if [ -n "${build_dir}" ]; then
    lit=${build_dir}/bin/llvm-lit
else
    lit=$(command -v lit)
fi

if [ -z "${lit}" ] || ! [ -x "${lit}" ]; then
   echo "Could not find suitable lit executable"
   exit 1
fi

# The kitsune tests must be run sequentially. Some CPU tapir targets like
# OpenCilk will use all the cores on the system by default. Running tests in
# parallel under such conditions is usually undesirable. Similarly, running the
# tests with GPU tapir targets in parallel will cause contention on the GPU
# which is not ideal either. It may be ok on a multi-gpu system, but for now, we
# don't check for that. The user can always use lit directly in those cases.
#
# TODO: It is not clear that we need NO_STOP_MESSAGE=1 for the Fortran tests,
# but keep it for now. We will definitely want to revisit this at some point.
NO_STOP_MESSAGE=1 ${lit} -j 1 -o ${kitsune}/ts-report.json ${kitsune}

# It is unlikely that there will be CPU's with different models on the test
# node. But if that does happen, we don't really care since this is only
# intended to be informational.
cpu="<<UNKNOWN>>"
cores="0"
if ls -l /proc/cpuinfo > /dev/null 2>&1; then
    cpu=$(cat /proc/cpuinfo \
              | grep "model name" \
              | sed 's/model name\s*:\s*//g' \
              | sort \
              | uniq)
    cores=$(cat /proc/cpuinfo \
                | grep "processor" \
                | sed 's/processor\s*:\s*//g' \
                | wc -l)
else
    echo "Looking up CPU info on non-Linux platforms not implemented"
fi

nvidia_smi=$(command -v nvidia-smi)
if [ $? -ne 0 ]; then

    nvidia_smi=""
fi

rocm_smi=$(command -v rocm-smi)
if [ $? -ne 0 ]; then
    rocm_smi=""
fi

# There could be more than one GPU on the machine. It would be good to determine
# which one was actually used, but at the time of writing, we cannot. It is
# unlikely that the suite will be run on a node with a variety of different
# GPU's on it. The more likely case is that there are multiple devices of the
# same model. Optimize for that scenario but be flexible enough to record all
# the GPU's if that is not the case.
gpu=""
devices=0
if [ -n "${nvidia_smi}" ]; then
    devices=$(nvidia-smi -L | wc -l)
    gpu=$(nvidia-smi -L \
                  | sed -E 's/GPU[ ]*[0-9]+:[ ]*//g' \
                  | sed -E 's/[ ]*[(]UUID:[ ]*.+[)]//g' \
                  | sort \
                  | uniq \
                  | tr '\n' ';' \
                  | sed -E 's/;$//g')
elif [ -n "${rocm_smi}" ]; then
    devices=$(rocm-smi -i | wc -l)
    gpu=$(rocm-smi -i \
              | grep "Device Name" \
              | awk -F':' '{print $3;}' \
              | sed -E 's/^\s*//g' \
              | sort \
              | uniq \
              | tr '\n' ';' \
              | sed -E 's/;$//g')
fi

date=$(date --rfc-3339=seconds)
host=$(hostname)

platform="{
  \"cpu\": {
    \"model\": \"${cpu}\",
    \"cores\": ${cores}
  },
  \"gpu\": {
    \"model\": \"${gpu}\",
    \"devices\": ${devices}
  },
  \"date\": \"${date}\",
  \"host\": \"${host}\"
}"

echo "${platform}" > ${kitsune}/platform.json

# Generate the combined report. There is no reason to do this as a separate
# step. It can always be done separately if needed. The -b option must be given
# the root of the test suite. The test
${kitsune}/utils/kit-combine \
     -b "${test_suite}" \
     -o "${outfile}" \
     "${kitsune}/ts-report.json"
